# Спектральная фильтрация сигнала

***Задание с 3 на 5.***

У вас есть сигнал в файле sample.dat (первый столбец -- время измерения в секундах, второй -- результат с осциллографа, третий столбец -- ошибка измерения осциллографа).
Вам известно, что интересующий вас сигнал имеет частоту в районе 100-300 Гц. Но помимо сигнала в данных есть шум.
Одним из источников шума является наводка от розетки, а вторым высокочастотные шумы электроники.

## **Задача:**

1) Построить данные
2) Построить спектр данных
3) Отфильтровать шум в соответствии со спектром
4) Построить сигнал
5) Подогнать полученный результат в модели косинуса и выдать частоту сигнала, его фазу и амплитуду с ошибками.

## **Справка**

* Спектр можно построить при помощи [numpy.fft.fft](https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html)
Не забывайте (вы этого, конечно, не знаете) после фурье-преобразования есть две ветки частот -- отрицательные и положительные. Вам об этом лучше не париться и просто смотреть на абсолютную величину, так как там есть симметрия.
Также не забывайте про различие между циклическими и линейными частотами (вам это уже известно).
Фурье смотрим как-то так:

```python
# FFT сигнала и получение амплитуды Фурье.
power_spectrum = np.abs(np.fft.fft(data))**2
# Вычисление соответствующих частот.
freqs = np.fft.fftfreq(n=signal_bkg.size, d=timestep)
idx = np.argsort(freqs)

# Строим.
plt.plot(freqs[idx], power_spectrum[idx])
plt.show()
```

* Подгонку можно выполнить при помощи [scipy.optimize.curve_fit](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html).
Выглядит это примерно так:

```python
from scipy.optimize import curve_fit
import numpy as np

xs = np.linspace(0, 4, 100)
ys = np.random.uniform(0, 1, 100)
# Ошибка y
sigma_y = np.random.uniform(0.05, 0.1, 100)

# Модель константного сигнала
def func(x, level: float):
    return level

popt, pcov = curve_fit(func, xs, ys, sigma=sigma_y, absolute_sigma=True)
# Результат подгонки
print(popt)
>> [0.50719743]
# Корень из диагональные элементы матрицы ковариации. Равны ошибкам соответствующих параметров подгонки
print(np.sqrt(np.diag(pcov)))
>> [0.00736794]
```
